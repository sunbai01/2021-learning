bfs or dfs问题的话

dfs方法论范式：基本点是栈，或者可以称之为递归
const dfs = (待遍历的数，递归深度) => {
    if (递归深度 || 找到了结果) {
        // 终结点！
    }
    
    for(走掉当次的所有可能性) {
        这次的可能性坐实（将走过的路标成1）
        dfs();
        这次完成后，还原，走下一个兄弟节点的可能性
    }
}

使用场景：创建dom树就是一个很明显的dfs



bfs方法论范式：基本点是队列， push shift 一层一层的入队列，进一层的时候将上一层的弹出去
const bfs = () => {
    // 创建一个队列，一个初始的点
    while(判断队列是否为空) {
        从队列头弹出一个当前层要处理的节点

        for(以此节点找出所有可以触达的节点) {
            if(满足条件) {
                创建新的节点
                新节点的某些值（count），要在上一节点的基础上 + 1
                新节点进入队列
                if(碰到可以结束的条件) {
                    结束，输出你的某些值（count）
                    return;
                }
            }
        }

    }
}


